/**
 * A base class for all Grits renderer extensions.  A renderer extension is
 * just a branch of functionality for the Grits renderer.  Although its not
 * entirely obvious, extensions are not the same as plugins.
 *
 * - Plugins are meant to allow Grits to be extended, at run-time, by external
 *   libraries and modules.
 *
 * - Extensions are internal partitions for the base functionality that Grits
 *   provides.  They primarily serve as a way to partition the logic of the
 *   renderer in a consistent way.
 *
 * @class Dasix.grits.AbsRenderExtension
 * @extends qx.core.Object
 * @author Luke Chavers <luke@chavers.io>
 * @since 0.1.0
 * @version 0.1.0
 * @copyright 2016 Dasix, Inc. All rights reserved.
 */

var qx = require( "qooxdoo" );
var _ = require( "lodash" );
var Promise = require( "bluebird" );
var tipe = require( "tipe" );

qx.Class.define(
	"Dasix.grits.AbsRenderExtension", {

		extend : qx.core.Object,

		/**
		 * @constructs Dasix.grits.AbsRenderExtension
		 * @param {Dasix.grits.Renderer} grits The grits renderer object in which
		 * this extension is extending.
		 */
		construct : function( grits ) {

			// Locals
			var me = this;

			// Grits MUST be defined
			if( grits === undefined || grits === null || grits.classname === undefined || grits.classname !== "Dasix.grits.Renderer" ) {
				throw new Error("Grits extension was instantiated without a reference to a Grits renderer object.");
			}

			// Store reference to grits renderer
			me.$$grits = grits;

			// Default log topic
			me.setLogTopic( null );

			// Call init(), if its available
			if( tipe( me.init ) === "function" ) {
				me.init();
			}

		},

		members : /** @lends Dasix.grits.AbsRenderExtension **/ {

			/**
			 * Sets the topic [prefix] for all log messages generated by the extension.
			 *
			 * @instance
			 * @access protected
			 * @param {string} newTopic
			 * @returns {void}
			 */
			setLogTopic: function( newTopic ) {

				var me = this;

				if( newTopic === undefined || newTopic === null || tipe(newTopic) !== "string" ) {
					newTopic = "extension";
				}

				me.$$logTopic = newTopic;

			},

			/**
			 * Returns a reference to the grits renderer object to which this
			 * extension is attached.
			 *
			 * @instance
			 * @access protected
			 * @returns {Dasix.grits.Renderer}
			 */
			getGrits: function() {
				var me = this;
				return me.$$grits;
			},

			/**
			 * This convenience alias exposes [plugin] event emission on the
			 * attached Grits renderer object.
			 *
			 * @instance
			 * @access protected
			 * @param {string} eventName The name of the event to emit.
			 * @param {?object} [eventData=NULL] Additional data to include in the event
			 * @returns {void}
			 */
			emit: function( eventName, eventData ) {

				var me = this;
				var grits = me.getGrits();
				grits.pluginManager.fireEvent( eventName, eventData );

			},

			/**
			 * Logs a message using a predefined log topic.
			 *
			 * @instance
			 * @access protected
			 * @param {string|string[]} message The log message to emit.
			 * @returns {void}
			 */
			log: function( message ) {

				var me = this;
				var grits = me.getGrits();

				var opts = grits._parseLogParams( arguments );

				// Update Log Topic
				if( opts.topic === null ) {
					opts.topic = me.$$logTopic;
				} else {
					opts.topic = me.$$logTopic + "." + opts.topic;
				}

				return grits.log( opts.level, opts.topic, opts.message );

			},

			/**
			 * Logs an error using a predefined log topic.  This method may
			 * cause the render operation to halt and the Grits application to exit.
			 *
			 * @access protected
			 * @instance
			 * @param {Error} err The error to log
			 * @param {boolean} canRecover Indicates whether or not this error can be
			 * recovered from.  This is used to prevent certain errors from crashing
			 * Grits.js when it is in 'watch' mode.
			 * @returns {void}
			 */
			logError: function( err, canRecover ) {

				var me = this;
				var grits = me.getGrits();
				grits.logError( me.$$logTopic, err, canRecover );

			},

			/**
			 * Logs a warning (non-critical error) using a predefined log topic.
			 * This method will NOT cause the render operation to halt or the
			 * Grits application to exit.
			 *
			 * @instance
			 * @access protected
			 * @param {Error} err The error to log
			 * @returns {void}
			 */
			logWarning: function( err ) {

				var me = this;
				var grits = me.getGrits();
				grits.logWarning( me.$$logTopic, err );

			},

			/**
			 * Logs a bit of source code or file content, with helpful
			 * markup like line numbers.
			 *
			 * @instance
			 * @access protected
			 * @param {string} name A name for the content, to make it easily identifiable.
			 * @param {string} content The content to log
			 * @returns {void}
			 */
			logSource: function( name, content ) {

				var me = this;
				var grits = me.getGrits();
				grits.logSource( me.$$logTopic, name, content );

			},

			/**
			 * Useful for logging a simple key/value (plain) object.
			 *
			 * @access public
			 * @param {object} obj The object to log.
			 * @returns {void}
			 */
			logObject: function( obj ) {
				this.getGrits().logObject( this.$$logTopic, obj );
			},

			/**
			 * Logs a single key/value pair using a bit of special
			 * formatting. (` -> key: val`).
			 *
			 * @access public
			 * @param {string} key The key (or name) of the value.
			 * @param {string} val The value to log.  If anything other than
			 * a string is passed then it will be coerced to a string before it is logged.
			 * @returns {void}
			 */
			logKeyVal: function( key, val ) {
				this.getGrits().logKeyVal( this.$$logTopic, key, val );
			},

			/**
			 * A formatting helper for logging the start of an operation.
			 * The special functionality of this method is purely cosmetic.
			 *
			 * @access public
			 * @param {string} str The operation name or title.
			 * @returns {void}
			 */
			logOpStart: function( str ) {
				this.getGrits().logOpStart( this.$$logTopic, str );
			},

			/**
			 * Adds configuration info to the watcher.
			 *
			 * @instance
			 * @access private
			 * @see Dasix.grits.ext.WatchManager#addWatchConfig
			 * @param {object} collection
			 * @param {function} handler
			 * @param {?string|string[]} [extensions=null]
			 * @returns {void}
			 */
			_addCollectionWatcher: function( collection, handler, extensions ) {

				// Locals
				var me = this;
				var grits = me.getGrits();

				// Defer to watch manager
				grits.watchManager.addCollectionWatcher( collection, handler, extensions );

			},

			/**
			 * Drop-in replacement for "require()" that forces cache invalidation
			 * before loading the module.  This ensures that you get the latest
			 * edition and a new reference each time.
			 *
			 * @instance
			 * @access public
			 * @param {string} path
			 * @returns {*}
			 */
			requireLatest: function( path ) {

				// Resolve the path
				var resolved = require.resolve( path );

				// Delete existing cache, if it exists
				if( require.cache[ resolved ] !== undefined ) {
					delete require.cache[ resolved ];
				}

				// Require and return
				return require( resolved );

			},

			/**
			 * Creates a keep-alive loop; this is useful for daemon-like extensions.
			 *
			 * @instance
			 * @access public
			 * @returns {object}
			 */
			keepAlive: function() {

				// Disabled, perhaps abandoned, will be addressed
				// in a later version ..
				return null;


				// Locals
				var me = this;

				// Already in keep-alive mode ..
				if( me.$$keepAlive === undefined || me.$$keepAlive === null ) {
					me.$$keepAlive = setInterval( function() {}, 3000 );
				}

				// Return the keep alive object
				return me.$$keepAlive;

			},

			/**
			 * Ends the keep-alive loop created by `keepAlive()`
			 *
			 * @instance
			 * @access public
			 * @returns {void}
			 */
			endKeepAlive: function() {

				// Disabled, perhaps abandoned, will be addressed
				// in a later version ..
				return;

				// Locals
				var me = this;

				// Nothing to do ..
				if( me.$$keepAlive === undefined || me.$$keepAlive === null ) {
					return;
				}

				//console.log("..dying");

				clearInterval( me.$$keepAlive );
				me.$$keepAlive = null;

			},

			/**
			 * Returns the `Dasix.grits.ext.ComponentConfigManager`
			 *
			 * @instance
			 * @access private
			 * @returns {object}
			 */
			getComponentConfigManager: function() {

				// Locals
				var me = this;
				var grits = me.getGrits();
				return grits.componentConfigManager;

			},

			/**
			 * This method is a convenience alias for 
			 * `Dasix.grits.ext.ComponentConfigManager#getComponentConfig()`
			 *
			 * @instance
			 * @access public
			 * @see Dasix.grits.ext.ComponentConfigManager#getComponentConfig
			 * @param {string} componentName The name of the component
			 * @param {?string} overrides Optional overrides to be applied to the
			 * merged configuration.  Values provided here will override ALL of
			 * the configuration layers.
			 * @returns {object}
			 */
			getComponentConfig: function( componentName, overrides ) {
				var me = this;
				var ccm = me.getComponentConfigManager();
				return ccm.getComponentConfig( componentName, overrides );
			},

			/**
			 * This method is a convenience alias for
			 * `Dasix.grits.ext.ComponentConfigManager#setFactoryConfig()`
			 *
			 * @instance
			 * @access public
			 * @see Dasix.grits.ext.ComponentConfigManager#setFactoryConfig
			 * @param {string} componentName The name of the component
			 * @param {object} config The factory default configuration for the component.
			 * @returns {void}
			 */
			setComponentFactoryConfig: function( componentName, config ) {
				var me = this;
				var ccm = me.getComponentConfigManager();
				ccm.setFactoryConfig( componentName, config );
			},

			/**
			 * This method is a convenience alias for
			 * `Dasix.grits.ext.ComponentConfigManager#setDefaultConfig()`
			 *
			 * @instance
			 * @access public
			 * @see Dasix.grits.ext.ComponentConfigManager#setDefaultConfig
			 * @param {string} componentName The name of the component being configured.
			 * @param {object} config The configuration data to inject.
			 * @returns {void}
			 */
			setComponentDefaultConfig: function( componentName, config ) {
				var me = this;
				var ccm = me.getComponentConfigManager();
				ccm.setDefaultConfig( componentName, config );
			}

		}
	}
);

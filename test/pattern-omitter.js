// Dependencies
var util = require("./lib/util");
var expect  = util.expect;
require("../lib/classes/pattern-omitter");

// Tests
describe("Pattern Omitter", function() {

	var po;
	beforeEach(function(){

		// Our pattern identifies strings within {brackets}
		var pattern = /\{[^}]*\}/g;

		// A simple test string
		var src 	= "ABCD{EFGH}IJKL{MNOP}QRST{UVWX}YZ";

		// Providing a name helps to prevent placeholder conflicts
		var name 	= "test";

		// Create a new "pattern omitter"
		po = new Dasix.grits.PatternOmitter( name, src, pattern );

		// Configure the placeholders.  We're intentionally
		// simplifying them for testing purposes; this would
		// increase the chances of edge accidents, so we wouldn't
		// do it in production.
		po.configurePlaceholders({
			prefix		: "..",
			delimiter	: ".",
			suffix		: ".."
		});

	});

	describe("Placeholder Generation", function() {

		it("should be configurable", function() {

			var str = po._createPlaceholderTag(0);
			expect( str ).to.equal( "..test.0.." );

		});

	});

	describe("#remove()", function() {

		it("should work properly", function() {

			var str = po.remove();
			var expected = "ABCD..test.0..IJKL..test.1..QRST..test.2..YZ";
			expect( str ).to.equal( expected );

		});

	});

	describe("#replace()", function() {

		it("should work properly", function() {

			// This is a prerequisite, remove() always needs to
			// be called, at least once, prior to a replace() call.
			po.remove();

			// Fake some handled (mutated) data that contains only
			// one of the three placeholders generated by #remove()
			var handled = "..test.1..";

			// Execute it
			var str = po.replace( handled );

			// Assert
			expect( str ).to.equal( "{MNOP}" );

		});

	});

	describe("#wrap()", function() {

		it("should work properly", function() {

			var str = po.wrap(
				function( interm ) {

					// Do a few mutations that affect the text outside
					// of our pattern AND _would_ affect the text INSIDE
					// of our pattern if not for the pattern omitter.
					// (Here's the whole point of this class..)
					interm = interm.replace(/[A-Z]/g, "*");

					// We can assert against our interm string too,
					// and will do so (for good measure).
					var expectedInterm = "****..test.0..****..test.1..****..test.2..**";
					expect( interm ).to.equal( expectedInterm );

					// All done
					return interm;
				}
			);

			// Notice how we've effectively protected the letters
			// within { } from the destructive regex (above).
			var expectedResult = "****{EFGH}****{MNOP}****{UVWX}**";
			expect( str ).to.equal( expectedResult );

		});

	});

});
